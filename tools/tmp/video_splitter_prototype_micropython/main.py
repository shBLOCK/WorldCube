from machine import Pin, SoftI2C
from time import sleep, sleep_ms, sleep_us

led = Pin(21, Pin.OUT)

LCD_EN = Pin(10, Pin.OUT, value=0)
LCD_BL = Pin(14, Pin.OUT, value=1)
LCD_CS = Pin(11, Pin.OUT, value=1)
LCD_SCK = Pin(12, Pin.OUT, value=0)
LCD_MOSI = Pin(13, Pin.OUT)

HDMI_EN = Pin(42, Pin.OUT, value=0)
HDMI_I2C = SoftI2C(scl=Pin(2), sda=Pin(1), freq=100_000)

def init_lcd():
    def spi_send(head, data):
        LCD_CS(0)
        LCD_MOSI(head)
        LCD_SCK(1)
        LCD_SCK(0)
        for _ in range(8):
            LCD_MOSI(data & 0x80)
            LCD_SCK(1)
            LCD_SCK(0)
            data <<= 1
        LCD_CS(1)

    def cmd(cmd, *data):
        spi_send(0, cmd)
        for byte in data:
            spi_send(1, byte)

    LCD_EN(0)
    sleep_ms(10)
    LCD_EN(1)
    sleep_ms(10)

    if True:
        cmd(0xFF, 0x77, 0x01, 0x00, 0x00, 0x13)  # goto bank 3
        cmd(0xEF, 0x08)  # ???

    cmd(0xFF, 0x77, 0x01, 0x00, 0x00, 0x00)  # goto bank 0
    cmd(0xC0, 0x3B, 0x00)  # 480 lines
    cmd(0xC1, 2, 2) # VBP VFP
    cmd(0xC2, 0x21, 0x08)  # ???
    cmd(0xC3, 0b0_000_0_0_0_0, 2, 2)  # RGBCTRL

    if True:
        cmd(0xFF, 0x77, 0x01, 0x00, 0x00, 0x00)  # goto bank 0
        cmd(0xB0, 0x00, 0x11, 0x18, 0x0E, 0x11, 0x06, 0x07, 0x08, 0x07, 0x22, 0x04, 0x12, 0x0F, 0xAA, 0x31, 0x18)
        cmd(0xB1, 0x00, 0x11, 0x19, 0x0E, 0x12, 0x07, 0x08, 0x08, 0x08, 0x22, 0x04, 0x11, 0x11, 0xA9, 0x32, 0x18)
        cmd(0xFF, 0x77, 0x01, 0x00, 0x00, 0x11)  # goto bank 1
        cmd(0xB0, 0x60)
        cmd(0xB1, 0x30)
        cmd(0xB2, 0x87)
        cmd(0xB3, 0x80)
        cmd(0xB5, 0x49)
        cmd(0xB7, 0x85)
        cmd(0xB8, 0x21)
        cmd(0xC1, 0x78)
        cmd(0xC2, 0x78)
    sleep_ms(20)  # await charge pump setup

    # color & other calibration?
    if True:
        cmd(0xFF, 0x77, 0x01, 0x00, 0x00, 0x11)  # goto bank 1
        cmd(0xE0, 0x00, 0x1B, 0x02)
        cmd(0xE1, 0x08, 0xA0, 0x00, 0x00, 0x07, 0xA0, 0x00, 0x00, 0x00, 0x44, 0x44)
        cmd(0xE2, 0x11, 0x11, 0x44, 0x44, 0xED, 0xA0, 0x00, 0x00, 0xEC, 0xA0, 0x00, 0x00)
        cmd(0xE3, 0x00, 0x00, 0x11, 0x11)
        cmd(0xE4, 0x44, 0x44)
        cmd(0xE5, 0x0A, 0xE9, 0xD8, 0xA0, 0x0C, 0xEB, 0xD8, 0xA0, 0x0E, 0xED, 0xD8, 0xA0, 0x10, 0xEF, 0xD8, 0xA0)
        cmd(0xE6, 0x00, 0x00, 0x11, 0x11)
        cmd(0xE7, 0x44, 0x44)
        cmd(0xE8, 0x09, 0xE8, 0xD8, 0xA0, 0x0B, 0xEA, 0xD8, 0xA0, 0x0D, 0xEC, 0xD8, 0xA0, 0x0F, 0xEE, 0xD8, 0xA0)
        cmd(0xEB, 0x02, 0x00, 0xE4, 0xE4, 0x88, 0x00, 0x40)
        cmd(0xEC, 0x3C, 0x00)
        cmd(0xED, 0xAB, 0x89, 0x76, 0x54, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x20, 0x45, 0x67, 0x98, 0xBA)
        cmd(0xEF, 0x10, 0x0D, 0x04, 0x08, 0x3F, 0x1F)

    cmd(0xFF, 0x77, 0x01, 0x00, 0x00, 0x00)  # goto bank 0
    cmd(0x3A, 0x77)  # RGB888

    if True:
        cmd(0xFF, 0x77, 0x01, 0x00, 0x00, 0x13)  # goto bank 3
        cmd(0xE8, 0x00, 0x0E)  # ???

    cmd(0xFF, 0x77, 0x01, 0x00, 0x00, 0x00)  # goto bank 0
    cmd(0x11)  # SLPOUT
    sleep_ms(120)

    if True:
        cmd(0xFF, 0x77, 0x01, 0x00, 0x00, 0x13)  # goto bank 3
        cmd(0xE8, 0x00, 0x0C)  # ???
        sleep_ms(10)
        cmd(0xE8, 0x00, 0x00)

    cmd(0xFF, 0x77, 0x01, 0x00, 0x00, 0x00)  # goto bank 0
    cmd(0x29)  # DISPON
    cmd(0x36, 0x00)  # MADCTL
    sleep_ms(20)


def init_hdmi():
    HDMI_EN(0)
    sleep_ms(10)
    HDMI_EN(1)
    sleep_ms(10)

    print("i2c.scan():", HDMI_I2C.scan())

    def wr(map_addr: int, reg: int, val: int):
        """Write one byte to a register."""
        HDMI_I2C.writeto_mem(map_addr >> 1, reg, bytes([val & 0xFF]))

    # ADV7611 I2C ADDRESSES
    wr(0x98, 0xF4, 0x80)  # CEC
    wr(0x98, 0xF5, 0x7C)  # INFOFRAME
    wr(0x98, 0xF8, 0x4C)  # DPLL
    wr(0x98, 0xF9, 0x64)  # KSV
    wr(0x98, 0xFA, 0x6C)  # EDID
    wr(0x98, 0xFB, 0x68)  # HDMI
    wr(0x98, 0xFD, 0x44)  # CP
    print("i2c.scan():", HDMI_I2C.scan())

    # wr(0x98, 0x00, 0b00_000111)
    wr(0x98, 0x00, 0b00_010000)
    wr(0x98, 0x02, 0b0001_0010)
    wr(0x98, 0x03, 0x40)
    wr(0x98, 0x04, 0b01100000)
    wr(0x98, 0x05, 0b00101000)
    wr(0x98, 0x06, 0b1_010_0_0_0_0)
    wr(0x98, 0x0B, 0x44)
    wr(0x98, 0x0C, 0x42)
    wr(0x98, 0x15, 0x80)
    wr(0x98, 0x19, 0x80)
    wr(0x98, 0x33, 0x40)
    wr(0x98, 0x14, 0x3F)
    wr(0x44, 0xBA, 0x01)
    wr(0x44, 0x7C, 0x01)
    wr(0x64, 0x40, 0x81)
    wr(0x68, 0x00, 0x00)
    wr(0x68, 0x01, 0b000_0000_1)
    wr(0x68, 0x83, 0xFE)

    # RECOMMENDED INITIALIZATION SETTINGS
    wr(0x44, 0x6C, 0x00)  # ADI required setting
    wr(0x68, 0x9B, 0x03)  # ADI required setting
    wr(0x68, 0x6F, 0x08)  # ADI required setting (optimized DVI detection)
    wr(0x68, 0x85, 0x1F)  # ADI required setting
    wr(0x68, 0x87, 0x70)  # ADI required setting
    wr(0x68, 0x57, 0xDA)  # ADI required setting
    wr(0x68, 0x58, 0x01)  # ADI required setting
    wr(0x68, 0x03, 0x98)  # Set DIS_I2C_ZERO_COMPR 0x03[7]=1
    wr(0x68, 0x4C, 0x44)  # Set NEW_VS_PARAM 0x44[2]=1

    # For non-fast switching applications, the following settings are recommended :
    wr(0x68, 0xC1, 0x01)  # ADI required setting
    wr(0x68, 0xC2, 0x01)  # ADI required setting
    wr(0x68, 0xC3, 0x01)  # ADI required setting
    wr(0x68, 0xC4, 0x01)  # ADI required setting
    wr(0x68, 0xC5, 0x01)  # ADI required setting
    wr(0x68, 0xC6, 0x01)  # ADI required setting
    wr(0x68, 0xC7, 0x01)  # ADI required setting
    wr(0x68, 0xC8, 0x01)  # ADI required setting
    wr(0x68, 0xC9, 0x01)  # ADI required setting
    wr(0x68, 0xCA, 0x01)  # ADI required setting
    wr(0x68, 0xCB, 0x01)  # ADI required setting
    wr(0x68, 0xCC, 0x01)  # ADI required setting

    # DYNAMIC SETTINGS FOR HDMI
    # Equalizer Settings
    # Device can support video modes above 480p/576p:
    wr(0x68, 0x8D, 0x04)  # LFG Port A
    wr(0x68, 0x8E, 0x1E)  # HFG Port A

    #####################

    #####################
    with open('480x480x6_100.edid', 'rb') as f:
        edid = f.read()
    if len(edid) != 256:
        raise ValueError("EDID file must be exactly 256bytes")
    wr(0x64, 0x77, 0x00)
    wr(0x64, 0x74, 0x00)
    for i, b in enumerate(edid):
        wr(0x6C, i, b)
    sleep_ms(10)
    wr(0x64, 0x77, 0x00)
    wr(0x64, 0x52, 0x20)
    wr(0x64, 0x53, 0x00)
    wr(0x64, 0x70, 0x9E)
    wr(0x64, 0x74, 0x01)

    wr(0x98, 0x15, 0b10100000) # disable tristate on pins
    wr(0x98, 0x0B, 0x44) # Powers up CP and digital sections of HDMI block; Powers up XTAL buffer to the digital core
    wr(0x98, 0x0C, 0x42) # Chip is operational,Disables power save mode,Powers up the clock to the CP core,Powers up the pads of the digital output pins

def main():
    init_lcd()
    init_hdmi()

main()
